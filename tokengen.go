package tokengen

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"strings"
	"time"
)

const (
	KeySalt = "github.com/hyuti/tokengen"
)

func hashData(value string) []byte {
	h := sha256.New()
	h.Write([]byte(value))
	return h.Sum(nil)
}
func hashAndEncryptWithSecretKey(value string, secretKey []byte) []byte {
	h := hmac.New(sha256.New, secretKey)
	h.Write([]byte(value))
	return h.Sum(nil)
}
func saltedHmac(keySalt, value, secretKey string) []byte {
	key := hashData(fmt.Sprintf("%s%s", keySalt, secretKey))
	return hashAndEncryptWithSecretKey(value, key)
}

func saltedHmacHex(keySalt, value, secretKey string) string {
	tk := saltedHmac(keySalt, value, secretKey)
	return hex.EncodeToString(tk)
}

func getTimestamp(t time.Time, loc *time.Location) uint64 {
	if loc == nil {
		loc = time.UTC
	}
	d := t.Sub(time.Date(2001, time.January, 1, 0, 0, 0, 0, loc))
	return uint64(d.Seconds())
}

func getNow() time.Time {
	return time.Now()
}

func makeTokenWithTs(keySalt, value, secretKey string, ts uint64) string {
	tk := saltedHmacHex(keySalt, value, secretKey)
	tk = extractEvenElements(tk)
	ts36 := convInt64ToBase36(ts)
	return fmt.Sprintf("%s-%s", ts36, tk)
}

// makeTokenWithSaltAndGetNow makes tests easier to mock timeout.
// For testing purpose only
func makeTokenWithSaltAndGetNow(keySalt, value, secretKey string, getNow func() time.Time) string {
	return makeTokenWithTs(keySalt, value, secretKey, getTimestamp(getNow(), nil))
}

// MakeTokenWithSalt allows you to use your key salt instead of default key salt
// To validate token generated by MakeTokenWithSalt use ValidateTokenWithKeySalt
// See ValidateTokenWithKeySalt
func MakeTokenWithSalt(keySalt, value, secretKey string) string {
	return makeTokenWithSaltAndGetNow(keySalt, value, secretKey, getNow)
}

// MakeToken uses default key salt
// To validate token generated by MakeToken use ValidateToken
// See ValidateToken
func MakeToken(value, secretKey string) string {
	return MakeTokenWithSalt(KeySalt, value, secretKey)
}

func validateToken(expectedTk, actualTk string) error {
	lAcTk := strings.Split(actualTk, "-")
	if len(lAcTk) != 2 {
		return errors.New("invalid format")
	}
	acTk := lAcTk[1]
	acTkB, err := hex.DecodeString(acTk)
	if err != nil {
		return err
	}
	lExTk := strings.Split(expectedTk, "-")
	if len(lExTk) != 2 {
		return errors.New("invalid format")
	}
	exTk := lExTk[1]
	exTkB, err := hex.DecodeString(exTk)
	if err != nil {
		return err
	}
	if !hmac.Equal(exTkB, acTkB) {
		return errors.New("invalid token")
	}
	return nil
}

func validateTokenWithKeySaltAndGetNow(keySalt, value, secretKey, actualTk string, timeout time.Duration, getNow func() time.Time) error {
	lAcTk := strings.Split(actualTk, "-")
	if len(lAcTk) != 2 {
		return errors.New("invalid format")
	}
	tsStr := lAcTk[0]
	ts := convBase36ToInt64(tsStr)

	if err := validateToken(makeTokenWithTs(keySalt, value, secretKey, ts), actualTk); err != nil {
		return err
	}

	if (getTimestamp(getNow(), nil) - ts) > uint64(timeout.Seconds()) {
		return errors.New("timeout exceeded")
	}
	return nil
}

// ValidateTokenWithKeySalt validates token and uses your key salt
// See MakeTokenWithSalt
func ValidateTokenWithKeySalt(keySalt, value, secretKey, actualTk string, timeout time.Duration) error {
	return validateTokenWithKeySaltAndGetNow(keySalt, value, secretKey, actualTk, timeout, getNow)
}

// ValidateToken validates token and uses the default key salt
// See MakeToken
func ValidateToken(value, secretKey, actualTk string, timeout time.Duration) error {
	return ValidateTokenWithKeySalt(KeySalt, value, secretKey, actualTk, timeout)
}
